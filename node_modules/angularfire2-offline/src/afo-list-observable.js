var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { ReplaySubject } from 'rxjs';
import { unwrap } from './database';
import { OfflineWrite } from './offline-write';
var stringify = require('json-stringify-safe');
export var AfoListObservable = (function (_super) {
    __extends(AfoListObservable, _super);
    /**
     * Creates the {@link AfoListObservable}
     * @param ref a reference to the related FirebaseListObservable
     * @param localUpdateService the service consumed by {@link OfflineWrite}
     */
    function AfoListObservable(ref, localUpdateService) {
        _super.call(this, 1);
        this.ref = ref;
        this.localUpdateService = localUpdateService;
        /**
         * An array used to store write operations that require an initial value to be set
         * in {@link value} before being applied
         */
        this.que = [];
        this.init();
    }
    /**
     * Emulates an offline write assuming the remote data has not changed
     * @param method AngularFire2 write method to emulate
     * @param value new value to write
     * @param key optional key used with some write methods
     */
    AfoListObservable.prototype.emulate = function (method, value, key) {
        if (value === void 0) { value = null; }
        var clonedValue = JSON.parse(JSON.stringify(value));
        if (this.value === undefined) {
            this.que.push({
                method: method,
                value: clonedValue,
                key: key
            });
            return;
        }
        this.processEmulation(method, clonedValue, key);
        this.updateSubscribers();
    };
    /**
     * - Gets the path of the reference
     * - Subscribes to the observable so that emulation is applied after there is an initial value
     */
    AfoListObservable.prototype.init = function () {
        var _this = this;
        this.path = this.ref.$ref.toString().substring(this.ref.$ref.database.ref().toString().length - 1);
        this.subscribe(function (newValue) {
            _this.value = newValue;
            if (_this.que.length > 0) {
                _this.que.forEach(function (queTask) {
                    _this.processEmulation(queTask.method, queTask.value, queTask.key);
                });
                _this.que = [];
                _this.updateSubscribers();
            }
        });
    };
    /**
     * Only calls next if the new value is unique
     */
    AfoListObservable.prototype.uniqueNext = function (newValue) {
        if (this.updated > 1 || (stringify(this.previousValue) !== stringify(newValue))) {
            this.previousValue = newValue;
            this.next(newValue);
            this.updated++;
        }
    };
    /**
     * Wraps the AngularFire2 FirebaseListObservable [push](https://goo.gl/nTe7C0) method
     *
     * - Emulates a push locally
     * - Calls the AngularFire2 push method
     * - Saves the write locally in case the browser is refreshed before the AngularFire2 promise
     * completes
     */
    AfoListObservable.prototype.push = function (value) {
        var resolve;
        var promise = new Promise(function (r) { return resolve = r; });
        var key = this.ref.$ref.push(value, function () {
            resolve();
        }).key;
        promise.key = key;
        this.emulate('push', value, key);
        OfflineWrite(promise, 'object', this.path + "/" + key, 'set', [value], this.localUpdateService);
        return promise;
    };
    /**
     * Wraps the AngularFire2 FirebaseListObservable [update](https://goo.gl/oSWgqn) method
     *
     * - Emulates a update locally
     * - Calls the AngularFire2 update method
     * - Saves the write locally in case the browser is refreshed before the AngularFire2 promise
     * completes
     */
    AfoListObservable.prototype.update = function (key, value) {
        this.emulate('update', value, key);
        var promise = this.ref.update(key, value);
        this.offlineWrite(promise, 'update', [key, value]);
        return promise;
    };
    /**
     * Wraps the AngularFire2 FirebaseListObservable [remove](https://goo.gl/MkZTtv) method
     *
     * - Emulates a remove locally
     * - Calls the AngularFire2 remove method
     * - Saves the write locally in case the browser is refreshed before the AngularFire2 promise
     * completes
     * @param remove if you omit the `key` parameter from `.remove()` it deletes the entire list.
     */
    AfoListObservable.prototype.remove = function (key) {
        this.emulate('remove', null, key);
        var promise = this.ref.remove(key);
        this.offlineWrite(promise, 'remove', [key]);
        return promise;
    };
    /**
     * Convenience method to save an offline write
     *
     * @param promise
     * [the promise](https://goo.gl/5VLgQm)
     * returned by calling an AngularFire2 method
     * @param type the AngularFire2 method being called
     * @param args an optional array of arguments used to call an AngularFire2 method taking the form of [newValue, options]
     */
    AfoListObservable.prototype.offlineWrite = function (promise, type, args) {
        OfflineWrite(promise, 'list', this.path, type, args, this.localUpdateService);
    };
    /**
     * Calculates the result of a given emulation without updating subscribers of this Observable
     *
     * - this allows for the processing of many emulations before notifying subscribers
     * @param method the AngularFire2 method being emulated
     * @param value the new value to be used by the given method
     * @param key can be used for remove and required for update
     */
    AfoListObservable.prototype.processEmulation = function (method, value, key) {
        var _this = this;
        if (this.value === null) {
            this.value = [];
        }
        var newValue = unwrap(key, value, function () { return value !== null; });
        if (method === 'push') {
            var found_1 = false;
            this.value.forEach(function (item, index) {
                if (item.$key === key) {
                    _this.value[index] = newValue;
                    found_1 = true;
                }
            });
            if (!found_1) {
                this.value.push(newValue);
            }
        }
        else if (method === 'update') {
            var found_2 = false;
            this.value.forEach(function (item, index) {
                if (item.$key === key) {
                    found_2 = true;
                    _this.value[index] = newValue;
                }
            });
            if (!found_2) {
                this.value.push(newValue);
            }
        }
        else {
            if (key === undefined) {
                this.value = [];
            }
            else {
                this.value.forEach(function (item, index) {
                    if (item.$key === key) {
                        _this.value.splice(index, 1);
                    }
                });
            }
        }
    };
    /**
     * Sends the the current {@link value} to all subscribers
     */
    AfoListObservable.prototype.updateSubscribers = function () {
        this.uniqueNext(this.value);
    };
    return AfoListObservable;
}(ReplaySubject));
